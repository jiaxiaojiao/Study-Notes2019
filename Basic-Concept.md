## 一些概念


#### 可见性/原子性/有序性

Java内存模型中的可见性、原子性、有序性

**可见性：** 

线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。

Java中volatile、synchronized和final实现可见性。

**原子性：**

原子是最小单位，具有不可分割性。

非原子操作都会存在线程安全问题。

Java中synchronized和Lock保证原子性。

**有序性：**

Java中volatile和synchronized保证线程之间操作的有序性。

volatile 禁止指令重排序

synchronized 一个变量在同一个时刻只允许一个线程对其进行lock操作。

#### 序列化，反序列化

对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序；从字节流创建对象的相反的过程称为反序列化。而创建的字节流是与平台无关的，在一个平台上序列化的对象可以在不同的平台上反序列化

**如何使Java类可序列化？**

通过实现java.io.Serializable接口，可以在Java类中启用可序列化。它是一个标记接口，意味着它不包含任何方法或字段，仅用于标识可序列化的语义。

#### 高可用

**可用性：**

计算机系统的可用性用平均无故障时间（MTTF）来度量，即计算机系统平均能够正常运行多长时间才发生一次故障。系统的可用性越高，平均无故障时间越长。

可维护性用平均维修时间（MTTR）来度量，即系统发生故障后维修和重新恢复正常运行平均花费的时间。系统的可维护性越好，平均维修时间越短。

计算机系统的可用性定义为： MTTF/(MTTF+MTTR)*100%

由此可见，计算机系统的可用性定义为系统保持正常运行时间的百分比。

**高可用：**

通过设计减少系统不能提供服务的时间。

保证系统的高可用性： 集群化，自动故障转移。

#### 高并发

**高并发：**

通过设计保证系统能够同时并行处理很多请求。

高并发相关的一些指标：响应时间，吞吐量，每秒查询率QPS，并发用户数等。
	
**如何提升系统的并发能力：**

互联网分布式架构设计，提高系统并发能力的方式主要有两种： 垂直扩展，水平扩展。

垂直扩展： 提升单机处理能力。

水平扩展：增加服务器数量。对架构设计是有要求的。

**如何处理高并发情况：**

1. HTML静态化

2. 图片服务器分离

3. 数据库集群和库表散列

4. 缓存

5. 镜像

6. 负载均衡

#### 分布式

**分布式：**

一个业务拆分为多个子业务，部署在多个服务器上。分布式系统具有高度的内聚性和透明性。

**分布式锁：**

控制分布式系统有序的对共享资源进行操作，通过互斥来保持一致性。

**分布式锁一般有三种实现方式**

1. 基于数据库的锁

	- 基于数据库表，方法名称约束唯一标识。

	- 通过数据库的排它锁

2. 基于缓存Redis的分布式锁

	使用redis命令 set key value NX EX max-lock-time 实现加锁

	使用redis命令 EVAL 实现解锁

	- 获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。

	- 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。

	- 释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。

3. 基于Zookeeper的分布式锁

	基于zookeeper临时有序节点可以实现的分布式锁。


#### 集群：

同一个业务，部署在多个服务器上。

