## 一些概念

### 目录
- [抽象漏洞定理](#抽象漏洞定理)
- [AI](#AI)
- [可见性/原子性/有序性](#可见性-原子性-有序性)
- [序列化/反序列化](#序列化-反序列化)
- [高可用](#高可用)
- [高并发](#高并发)
- [分布式](#分布式)
- [微服务](#微服务)
- [集群](#集群)
- [缓存](#缓存)
- [JMS](#JMS)
- [BlockingQueue](#BlockingQueue)
- [OA系统](#OA系统)
- [BPM](#BPM)
- [IDE](#IDE)

### 抽象漏洞定理

抽象漏洞定理：抽象可以节约我们工作的时间，但是节约不了我们学习的时间。

The Law of Leaky Abstractions: The abstractions save us time working,but they don't save us time learning.


### AI 
> Artificial Intelligence
> 人工智能

实际应用：

机器视觉，指纹识别，人脸识别，视网膜识别，虹膜识别，掌纹识别，专家系统，自动规划，智能搜索，定理证明，博弈，自动程序设计，智能控制，机器人学，语言和图像理解，遗传编程等。

### 可见性 原子性 有序性

Java内存模型中的可见性、原子性、有序性。

**可见性：** 

线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。

Java中volatile、synchronized和final实现可见性。

**原子性：**

原子是最小单位，具有不可分割性。

非原子操作都会存在线程安全问题。

Java中synchronized和Lock保证原子性。

**有序性：**

Java中volatile和synchronized保证线程之间操作的有序性。

volatile 禁止指令重排序

synchronized 一个变量在同一个时刻只允许一个线程对其进行lock操作。

### 序列化 反序列化

对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序；从字节流创建对象的相反的过程称为反序列化。而创建的字节流是与平台无关的，在一个平台上序列化的对象可以在不同的平台上反序列化

**如何使Java类可序列化？**

通过实现java.io.Serializable接口，可以在Java类中启用可序列化。它是一个标记接口，意味着它不包含任何方法或字段，仅用于标识可序列化的语义。

### 高可用

**可用性：**

计算机系统的可用性用平均无故障时间（MTTF）来度量，即计算机系统平均能够正常运行多长时间才发生一次故障。系统的可用性越高，平均无故障时间越长。

可维护性用平均维修时间（MTTR）来度量，即系统发生故障后维修和重新恢复正常运行平均花费的时间。系统的可维护性越好，平均维修时间越短。

计算机系统的可用性定义为： MTTF/(MTTF+MTTR)*100%

由此可见，计算机系统的可用性定义为系统保持正常运行时间的百分比。

**高可用：**

通过设计减少系统不能提供服务的时间。

保证系统的高可用性： 集群化，自动故障转移。

### 高并发

**高并发：**

通过设计保证系统能够同时并行处理很多请求。

高并发相关的一些指标：响应时间，吞吐量，每秒查询率QPS，并发用户数等。
	
**如何提升系统的并发能力：**

互联网分布式架构设计，提高系统并发能力的方式主要有两种： 垂直扩展，水平扩展。

垂直扩展： 提升单机处理能力。

水平扩展：增加服务器数量。对架构设计是有要求的。

**如何处理高并发情况：**

1. HTML静态化

2. 图片服务器分离

3. 数据库集群和库表散列

4. 缓存

5. 镜像

6. 负载均衡

### 分布式

**分布式：**

一个业务拆分为多个子业务，部署在多个服务器上。分布式系统具有高度的内聚性和透明性。

**分布式锁：**

控制分布式系统有序的对共享资源进行操作，通过互斥来保持一致性。

**分布式锁一般有三种实现方式**

1. 基于数据库的锁

	- 基于数据库表，方法名称约束唯一标识。

	- 通过数据库的排它锁

2. 基于缓存Redis的分布式锁

	使用redis命令 set key value NX EX max-lock-time 实现加锁

	使用redis命令 EVAL 实现解锁

	- 获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。

	- 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。

	- 释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。

3. 基于Zookeeper的分布式锁

	基于zookeeper临时有序节点可以实现的分布式锁。

**如何构建全局唯一ID**

- java.util.UUID包下jdk 1.5之后新增的类java.util.UUID#randomUUID

- 数据库自增主键。

- SnowFlake算法即雪花算法

- 第三方软件生成（Redis）

    - Redis实现了一个原子操作INCR和INCRBY实现递增的操作

**分布式Session的一致性**

**分布式Session的设置**

### 微服务

**微服务的划分、粒度**

三种拆分方案：
- 方案一（新浪微博微服务专家胡忠想）
    1. 从业务维度进行拆分，关联比较密切的业务拆分成一个微服务。
    2. 功能且独立的功能。
- 方案二（阿里）
    1. 服务拆分要迎合业务的需要。充分考虑业务的独立性和专业性。
    2. 拆分后的维护成本要低于拆分前。
    3. 确保拆分后的服务由相对独立的团队负责维护。
    4. 拆分最有价值的结果是提高了系统的可扩展性
    5. 考虑软件发布频率
- 方案三（资深技术专家李运华）
    1. 基于业务逻辑
    2. 基于稳定性
    3. 基于可靠性
    4. 基于高性能

### 集群

同一个业务，部署在多个服务器上。

### 缓存

**缓存是什么？**

- 高速缓冲存储器，其中复制了频繁使用的数据以利于快速访问。

- 位于速度相差较大的两种硬件/软件之间，用于协调两者数据传输速度差异的结构

**缓存的分类**

基于web应用系统架构图：

浏览器 --> Web服务器 --> 应用服务器 -->  数据库 --> 存储设备 

在系统架构不同的层级见，为了加快访问速度，都存在添加缓存：

- 操作系统磁盘缓存->减少磁盘机械操作

- 数据库缓存->减少文件系统I/O

- 应用程序缓存->减少对数据库的查询 

- Web服务器缓存->减少应用服务器请求

- 客户端浏览器缓存->减少对网站的访问

### JMS

Java Message Service，Java消息服务应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间或分布式系统中发送消息，进行异步通信。

### BlockingQueue

### OA系统

Office Automation System
  
办公自动化系统，是面向组织的日常运作和管理，员工及管理者使用频率最高的应用系统。

### BPM
    
Business Process Management

业务流程管理

### IDE

Integrated Development Environment 集成开发环境

[**返回首页目录**](README.md)