## Java的垃圾回收

> 文章的摘要和笔记

### 目录
- [聊聊Java的垃圾回收](#聊聊Java的垃圾回收)

### 聊聊Java的垃圾回收

来自微信公众号阿里巴巴中间件率鸽的文章《咱们从头到尾说一次 Java 垃圾回收》

#### 什么是垃圾回收

垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。

1960年，基于 MIT 的 Lisp 首先提出了垃圾回收的概念。

#### 怎么定义垃圾

1. 引用计数算法（Reference Counting）

    缺点： 无法收集到循环依赖的情况。

2. 可达性分析算法（Reachability Analysis）

    描述：无法与引用链 GC Root 建立直接或间接的连接，系统就会判定为可回收对象。
    
#### 怎么回收垃圾

如何高效的进行垃圾回收？

1. 标记-清除算法（Mark-Sweep）
    
    问题： 产生内存碎片。

2. 复制算法（Copying）

    优点： 解决了内存碎片的问题。
    
    问题： 内存浪费。
    
3. 标记-整理算法（Mark-Compact）

    优点： 解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。
    
    问题： 内存频繁变动，效率差。
    
4. 分代收集算法（Generational Collection）

    描述： 融合了上述三种算法，针对不同情况采用不同算法。
    
    一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
    
    在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
    
    而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记-整理算法来进行回收。
    
#### 内存模型和回收策略

Java堆（Java Heap）是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域。

- Java堆

    - 年轻代

        - Eden 区

            大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。

        - Survivor 区
        
            Survivor 区相当于是 Eden 区和 Old 区的一个缓冲。

            - From 区

            - To 区
            
                每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）
                
            Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。

    - 老年代
    
        老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长。
        
        老年代这里采用的是标记-整理算法。
        
        在内存担保机制下，无法安置的对象会直接进到老年代。
        
        1. 大对象
        2. 长期存活对象
        3. 动态对象年龄     

