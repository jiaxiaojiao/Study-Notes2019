## JVM的垃圾回收机制

### 那些内存需要回收（垃圾收集）

JVM的内存结构包括：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆区和方法区，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。

垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法。

1. 引用计数法

2. 可达性分析算法

3. Java中的引用（强引用、软引用、弱引用、虚引用）

4. 标记

5. 方法区存储内容是否需要回收。

### 常用的垃圾收集算法

1. 标记-清除算法（Mark-Sweep）

2. 复制算法(Copying)

3. 标记-整理算法(Mark-compact)

4. 分代收集算法

### 垃圾收集器

1. Serial收集器（复制算法)

2. Serial Old收集器(标记-整理算法)

3. ParNew收集器(停止-复制算法)　

4. Parallel Scavenge收集器(停止-复制算法)

5. Parallel Old收集器(停止-复制算法)

6. CMS(Concurrent Mark Sweep)收集器（标记-清理算法）

7. G1

### GC是什么时候触发的

由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。

1. Scavenge GC

    一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。
    
2. Full GC

    对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：
    
    a) 年老代（Tenured）被写满；
    
    b) 持久代（Perm）被写满；
    
    c) System.gc()被显示调用；
    
    d) 上一次GC之后Heap的各域分配策略动态变化；