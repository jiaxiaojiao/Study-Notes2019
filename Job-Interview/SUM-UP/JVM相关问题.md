
## JVM相关问题

#### 什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别？

JDK: 顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。

JRE: 普通用户而只需要安装JRE（Java Runtime Environment）来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。

JVM： 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。

区别与联系：
- JDK用于开发，JRE用于运行java程序 ；
- JDK和JRE中都包含JVM ；
- JVM是java编程语言的核心并且具有平台独立性。

#### 1. JVM内存结构，运行机制

Java的内存结构： 
- 方法区：常量池、变量等存储地方；（持久区）
- 堆：实例对象存储地方；GC重点关照位置；（新生代和老年代）
- 程序计数器：记录程序下一步指令；
- Java方法栈：方法程序运行地方；Java栈总是与线程关联在一起的，每当创建一个线程，JVM就会为该线程创建对应的Java栈；
- 本地方法栈：java方法与本地相关联

JVM运行机制：JVM转入环境和配置（java.exe-->jvm.cfg）、装载JVM（通过LoadJavaVM来装载）、启动JVM获得本地调用接口、运行java程序；


#### 2. 介绍下垃圾回收机制，垃圾回收机制有哪些算法，各自的特点。

GC的对象是堆空间和永久区，防止内存泄漏。

垃圾回收算法
- **引用计数法**， 通过引用数量来回收垃圾。问题：引用和去引用 影响性能，很难处理循环引用。 没有被Java采用。
- **标记清除法**， 现在垃圾回收算法的思想基础。
- **标记压缩法**， 适用于存活对象较多的场合，如老年代。
- **复制算法**，相对高效，不适合存活对象较多的场合，如老年代。问题，空间浪费。

#### 分代思想
依据对象的存活周期进行分来，短命对象新生代，长命对象老年代。
- 新生代，少量对象存活，适合复制算法。
- 老年代，大量对象存活，适合标记清理或标记压缩。

#### 3. 聊聊Minor GC、Major GC和Full GC之间的区别，垃圾收集器有哪些，他们的区别？
Minor GC： 从年轻代空间（包括 Eden 和 Survivor 区域）回收内存
Major GC： 清理老年代
Full GC： 清理整个堆空间—包括年轻代和老年代

垃圾收集器
- Serial收集器 ：串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停） 
- ParNew收集器 ： 其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩。
- Parallel收集器 ： 类似ParNew收集器，Parallel收集器更关注系统的吞吐量。
- Parallel Old 收集器 ： Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供
- CMS收集器 ： 是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。
- G1收集器 ： G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：1. 空间整合，2. 可预测停顿。

#### 4. OutOfMemoryError  怎么处理
导致OutOfMemoryError异常的常见原因有以下几种：
- 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
- 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
- 代码中存在死循环或循环产生过多重复的对象实体；
- 使用的第三方软件中的BUG；
- 启动参数内存值设定的过小；

此错误常见的错误提示：
- tomcat:java.lang.OutOfMemoryError: PermGen space
- tomcat:java.lang.OutOfMemoryError: Java heap space
- weblogic:Root cause of ServletException java.lang.OutOfMemoryError
- resin:java.lang.OutOfMemoryError
- java:java.lang.OutOfMemoryError

解决java.lang.OutOfMemoryError的方法有如下几种：
- 增加jvm的内存大小。
- 优化程序，释放垃圾。

重点排查以下几点：
- 检查代码中是否有死循环或递归调用。
- 检查是否有大循环重复产生新对象实体。
- 检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
- 检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。

#### 5. JVM调优有哪些参数

参数 | 说明
--- | --- 
-Xms | 初始堆的分配大小，默认为物理内存的六十四分之一
-Xmx | 堆的最大分配大小（默认为物理内存的四分之一）
-Xmn | 新生代的大小
-XX:PermSize | 设置持久代(perm gen)初始值（物理内存的1/64）
-XX:MaxPermSize | 设置持久代最大值（物理内存的1/4）



#### 6. 自己写一个类叫 java.lang.String 类加载过程，双亲委派模型。

类加载器就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。

如果站在JVM的角度来看，只存在两种类加载器:
- 启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。
- 其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：
    - 扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。
    - 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。

双亲委派模型的原理很简单，实现也简单。每次通过先委托父类加载器加载，当父类加载器无法加载时，再自己加载。其实ClassLoader类默认的loadClass方法已经帮我们写好了，我们无需去写。

