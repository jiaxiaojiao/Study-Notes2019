# GC 垃圾回收
> GC的对象是堆空间和永久区，防止内存泄漏。

## 垃圾回收算法

#### 标记-清除算法 Mark-Sweep GC
> 现在垃圾回收算法的思想基础。

mark-sweep 分为两个阶段：
1. 标记阶段：从根集合出发，将所有活动对象及其子对象打上标记
2. 清除阶段：遍历堆，将非活动对象（未打上标记）的连接到空闲链表上

优点：
- 实现简单， 容易和其他算法组合

缺点：
- 碎片化， 会导致无数小分块散落在堆的各处
- 分配速度不理想，每次分配都需要遍历空闲列表找到足够大的分块
- 与写时复制技术不兼容，因为每次都会在活动对象上打上标记

#### 标记-压缩 Mark-Compact
> 适用于存活对象较多的场合，如老年代。

和“标记－清除”相似，不过在标记阶段后它将所有活动对象紧密的排在堆的一侧（压缩），消除了内存碎片， 不过压缩是需要花费计算成本的。

优点:
- 有效利用了堆，不会出现内存碎片 也不会像复制算法那样只能利用堆的一部分

缺点:
- 压缩过程的开销，需要多次搜索堆

#### 引用计数 Reference Counting
> 没有被Java采用。

引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时更新计数器，如果计数器值为0则直接回收内存。 很明显，引用计数最大的优势是暂停时间短

优点:
- 可即刻回收垃圾
- 最大暂停时间短
- 没有必要沿指针查找， 不要和标记-清除算法一样沿着根集合开始查找

缺点：
- 计数器的增减处理繁重
- 计数器需要占用很多位
- 实现繁琐复杂， 每个赋值操作都得替换成引用更新操作
- 循环引用无法回收

#### GC 复制算法
> 相对高效，不适合存活对象较多的场合，如老年代。问题，空间浪费。

将堆分为两个大小相同的空间 From 和 To， 利用 From 空间进行分配，当 From 空间满的时候，GC将其中的活动对象复制到 To 空间，之后将两个空间互换即完成GC。 

优点：
- 优秀的吞吐量， 只需要关心活动对象
- 可实现高速分配； 因为分块是连续的，不需要使用空闲链表
- 不会发生碎片化
- 与缓存兼容

缺点：
- 堆使用率低
- 与保守式GC不兼容
- 递归调用函数， 复制子对象需要递归调用复制函数 消耗栈

#### 保守式GC
根空间有以下几种：
- 寄存器
- 调用栈
- 全局变量空间

但这些都是不明确的根， 因为调用栈里边的调用帧(call frame) 既有指针也有非指针（值类型）

保守式GC检查不明确根的基本项目：
- 是不是被正确对齐的值？（在32位cpu的情况下，为4的倍数）
- 是不是指针堆内？
- 是不是指着对象的开头？

有种情况是，非指正和堆里的对象地址一样；这时保守式GC “把可以的东西看做指针，稳妥处理”

保守式GC优点：
- GC不依赖于语言处理程序
缺点：
- 识别指针和非指针需要成本
- 错误识别指针会压迫堆； 可能错将非指针当做指针,然后将其作为内存地址使得对应堆中的死对象当做活对象
- 能够使用的gc算法有限； 不能使用复制算法这类移动对象的gc算法

**准确式GC**

需要依赖 “语言处理程序的支援”，能基于能精确识别指针和非指针的“正确根”来执行gc

#### 分代回收

出发点：大部分对象生成后马上就变成垃圾，很少有对象能活的很久
- 新生代 =  生成空间 + 2 * 幸存区  复制算法
- 老年代 标记-清除算法

对象在生成空间创建，当生成空间满之后进行 minor gc，将活动对象复制到第一个幸存区，并增加其“年龄” age，当这个幸存区满之后再将此次生成空间和这个幸存区的活动对象复制到另一个幸存区，如此反复，当活动对象的 age 达到一定次数后将其移动到老年代； 当老年代满的时候就用标记-清除或标记-压缩算法进行major gc

吞吐量得到改善， 分代垃圾回收花费的时间是GC复制算法的四分之一；但是如果部分程序新生成对象存活很久的话分代回收会适得其反

#### 增量式GC

本来gc只是默默的在幕后回收资源的，但是如果gc任务繁重则会长时间暂停应用程序的执行， 增量式gc就是一种逐渐推进垃圾回收来控制mutator最大暂停时间的方法

三色标记算法：
- 白色： 还未搜索过的对象
- 灰色： 正在搜索的对象
- 黑色： 搜索完成的对象

根查找阶段： 对能直接从根引用的对象打上标记，堆放到标记栈里（白色 涂成 灰色）

标记阶段： 从标记栈中取出对象，将其子对象涂成灰色；这个阶段不是一下子处理所有的灰色对象，而只是处理一定个数，然后暂停gc

清除阶段： 将没被标记的白色对象连接到空闲链表，并重置已标记的对象标记位

优点： 
- 缩短最大暂停时间

缺点：
- 降低了吞吐量


## 分代思想
依据对象的存活周期进行分来，短命对象新生代，长命对象老年代。

新生代，少量对象存活，适合复制算法。

老年代，大量对象存活，适合标记清理或标记压缩。

## 可触及性
可触及，可复活，不可触及

