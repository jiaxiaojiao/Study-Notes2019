# Redis常见应用场景

## 1. 热点数据的缓存

> 由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。

## 2. 限时业务的运用

> redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

## 3. 计数器相关问题

> redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

## 4. 排行榜相关问题

> 关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。

## 5. 分布式锁

> 这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0，如果服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间 就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。

> 当然我们可以将这个特性运用于其他需要分布式锁的场景中，结合过期时间主要是防止死锁的出现。

Redis实现分布式锁：
#####1. 在获取锁之前先查询一下以该锁为key对应的value存不存在，如果存在，则说明该锁被其他客户端获取了，否则的话就尝试获取锁，获取锁的方法很简单，只要以该锁为key，设置一个随机的值就行了。
使用原子命令 SET my_key my_value NX PX milliseconds

设置过期时间。

获取锁后会将释放锁的代码放在finally块中。原子操作释放锁（Lua脚本）

可能的问题：获取到的锁不一定是排他锁，也就是说同一把锁同一时间可能被不同客户端获取到。仔细分析一下getLock方法，该方法并不是原子性的，当一个客户端检查到某个锁不存在，并在执行setKey方法之前，别的客户端可能也会检查到该锁不存在，并也会执行setKey方法，这样一来，同一把锁就有可能被不同的客户端获取到了。


## 6. 延时操作

## 7. 分页、模糊搜索

> redis的set集合中提供了一个zrangebylex方法，语法如下：

> ZRANGEBYLEX key min max [LIMIT offset count]

> 通过ZRANGEBYLEX zset - + LIMIT 0 10 可以进行分页数据查询，其中- +表示获取全部数据

> zrangebylex key min max 这个就可以返回字典区间的数据，利用这个特性可以进行模糊查询功能。

## 8. 点赞、好友等相互关系的存储

> Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 又或者在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。

## 9. 队列

> 由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。
