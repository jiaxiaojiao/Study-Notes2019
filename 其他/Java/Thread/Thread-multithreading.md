# 多线程

## 多线程编程优势：
- 提高系统的吞吐率，一个进程中可以有多个并发的操作。
- 提高响应性，一个请求处理慢了不会影响其他请求的处理。
- 充分利用多核CPU资源，避免了资源浪费。
- 最小化对系统资源的使用，一个进程中的多个线程可以共享所在进程所申请的资源，如内存空间。
- 简化程序结构。

## 多线程编程的问题和风险：
- 线程安全问题。
- 线程的生命特征问题。
- 上下文切换。增加了系统的消耗，不利于系统的吞吐率。
- 可靠性。

## 实现多线程：
1. 继承Thread类，重写run方法。
2. 实现Runnable接口，并实现接口的run方法。
    1. 自定义类并实现Runnable接口，实现run方法。
    2. 创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象。
    3. 调用Thread的start方法。
3. 实现Callable接口，重写call()方法。
    1. 比Runnable更强大，任务结束后提供一个返回值，call()可以抛出异常，异步计算模型。
    
## 多线程包常用类：
集合类，创建线程池或线程，消息推送，同步代码块、锁、volatile

## 线程并发的处理，多线程同步机制
- synchronized 同步关键字： 同步方法，同步代码块。
- wait() 方法和notify()方法。等待、唤醒。
- Lock 锁

## 线程的生命周期/状态
线程的状态：运行，就绪，挂起，结束。

## run和Start的区别：
- start()方法来启动一个线程，就绪状态。JVM通过run()方法来完成实际的操作。（异步调用run()）
- 直接调用run()方法，同步的。
- 只有通过调用线程类的start()方法才能真正达到多线程的目的。

## 如何打断线程
- Thread.stop() 终止线程，释放已经锁定的所有监听资源。 不推荐，发生问题很难定位。
- suspend() 不会释放锁，容易发生死锁。不推荐。
- 让线程自行结束进入Dead状态。通过使用interrupt()方法来打破阻塞。

## 大数据的处理，高并发的解决方案
- HTML 静态化，缓解服务器压力。
- 文件服务器，转移压力。
- CDN 内容分发网络。
- 负载均衡
    - 集群，多台服务器。
    - 分布式
- 服务分布式部署
- 并发编程
- 反向代理。Nginx，将用户的请求分发到空闲的服务器上。
- 动静分离。
    - 网站静态资源与后台应用分开部署。静态资源部署到Nginx上，静态资源部署到CDN上
    - API接口服务化
- 数据库SQL优化，表结构优化，索引优化，
- 缓存。分布式缓存。减少数据库访问压力，快。缓存框架Ehcache，Memcache，Redis等
- 数据库读写分离
- 数据库活跃数据分离
- 存储过程。处理一次请求多次访问数据库的操作。


## 如何保障请求执行顺序
- 消息队列（MQ）
- 简单轻量级的可以考虑使用 Redis. 借助 Redis 的list结构。

## 其他多线程的问题

## 支付环节优化

## 预估成交量
