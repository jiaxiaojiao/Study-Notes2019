## Redis
- Redis 默认访问端口。
```text
默认端口6379

为什么选择6379作为默认端口：
6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字。
MERZ长期以来被antirez及其朋友当做愚蠢的代名词。
```

- Redis 数据类型
```text
它支持多种类型的数据结构，如：
字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 
```

- Redis的持久化机制？
```text
Redis的存储机制/持久化机制分为两种： 快照Snapshot，只追加文件AOF。无论哪种机制，Redis都是将数据存储在内存中。

快照Snapshot：是将数据先存储在内存，然后当数据累计到达某些特定的阈值的时候，就会触发一次DUMP操作，将变化的数据一次性写入数据文件RDB文件。性能高。

只追加文件AOF：是将数据先存储在内存，但是在存储的时候会使用调用fsync来完成对本次操作的日志记录，这个日志记录揭露文件其实是一个基于Redis的网络交互协议的文本文件。采用日志追加的方式来持久化数据。实时存储或准实时模式，频率高效率偏低，安全性高。

```
- Redis的过期策略？
```text
Redis的过期策略/Redis是怎么删除已经设置过期时间的Key的？

定期删除： redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。

惰性删除： 定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。


如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ redis内存淘汰机制。

Redis的内存淘汰机制： 
1. volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。
2. volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰。
3. volatile-random 从已设置过期时间的数据集中任意选择数据淘汰。
4. allkeys-lur 从数据集中挑选最近最少使用的数据淘汰
5. allkeys-random 从数据集中任意选择数据淘汰、
6. no-enviction 禁止驱逐数据
4.0版本后增加了两种：
1. volatile-lfu 从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。
2. allkeys-lfu 当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key

```
- 怎么保证Redis的高可用？
- 什么是缓存穿透，如何避免？
```text
缓存穿透：请求缓存中不存在的数据。常见的解决方案布隆过滤器。
```
- 什么是缓存雪崩，如何避免？
```text
缓存雪崩： 缓存大面积失效。

如何避免： 保证Redis集群高可用，选择合适的内存淘汰策略。


```
- 如何保证缓存与数据的双写一致性？
```text
如果要求缓存和数据库必须一致，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。
串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。
```
- Redis单线程模型原理，为什么能支撑高并发？
```text
redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。
它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：
1. 多个 socket
2. IO 多路复用程序
3. 文件事件分派器
4. 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，
但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，
事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

效率高：
1. 纯内存操作
2. 核心是基于非阻塞的 IO 多路复用机制
3. 单线程反而避免了多线程的频繁上下文切换问题

```
- Redis哨兵架构的理解和底层原理？

    Redis的哨兵(sentinel) 系统用于管理多个 Redis 服务器,该系统执行以下三个任务:
    - 监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。
    - 提醒(Notification):当被监控的某个 Redis出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。
    - 自动故障迁移(Automatic failover):当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作,它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master; 当客户端试图连接失效的Master时,集群也会向客户端返回新Master的地址,使得集群可以使用Master代替失效Master。

